<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="gfs," />










<meta name="description" content="The Google File SystemGFS是google三驾马车之一，是大型的分布式文件系统。所以了解GFS，对了解分布式系统非常有帮助。这篇博客主要从论文和一个小Demo对GFS进行讲解。 GFS论文理解GFS作为google的分布式文件系统，本身根据google的业务场景的业务场景，即大部分文件操作都是追加写，覆盖原有数据的情况比较少等特征，GFS做了对应的调整和优化。本文不会解释GF">
<meta name="keywords" content="gfs">
<meta property="og:type" content="article">
<meta property="og:title" content="GFS分析">
<meta property="og:url" content="https&#x2F;&#x2F;twdlll.github.io&#x2F;2019&#x2F;12&#x2F;04&#x2F;gfs&#x2F;index.html">
<meta property="og:site_name" content="Twd&#39;s Home">
<meta property="og:description" content="The Google File SystemGFS是google三驾马车之一，是大型的分布式文件系统。所以了解GFS，对了解分布式系统非常有帮助。这篇博客主要从论文和一个小Demo对GFS进行讲解。 GFS论文理解GFS作为google的分布式文件系统，本身根据google的业务场景的业务场景，即大部分文件操作都是追加写，覆盖原有数据的情况比较少等特征，GFS做了对应的调整和优化。本文不会解释GF">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="&#x2F;images&#x2F;gfs&#x2F;gfs_architecture.png">
<meta property="og:image" content="&#x2F;images&#x2F;gfs&#x2F;lease.png">
<meta property="og:image" content="&#x2F;images&#x2F;gfs&#x2F;consistency_model.png">
<meta property="og:image" content="&#x2F;images&#x2F;gfs&#x2F;gfsdemo_result.png">
<meta property="og:updated_time" content="2019-12-05T15:03:49.067Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="&#x2F;images&#x2F;gfs&#x2F;gfs_architecture.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https//twdlll.github.io/2019/12/04/gfs/"/>





  <title>GFS分析 | Twd's Home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Twd's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https//twdlll.github.io/2019/12/04/gfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Twd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Twd's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GFS分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-04T00:00:00+08:00">
                2019-12-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-05T23:03:49+08:00">
                2019-12-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="The-Google-File-System"><a href="#The-Google-File-System" class="headerlink" title="The Google File System"></a>The Google File System</h1><p>GFS是google三驾马车之一，是大型的分布式文件系统。所以了解GFS，对了解分布式系统非常有帮助。这篇博客主要从论文和一个小Demo对GFS进行讲解。</p>
<h2 id="GFS论文理解"><a href="#GFS论文理解" class="headerlink" title="GFS论文理解"></a>GFS论文理解</h2><p>GFS作为google的分布式文件系统，本身根据google的业务场景的业务场景，即大部分文件操作都是追加写，覆盖原有数据的情况比较少等特征，GFS做了对应的调整和优化。本文不会解释GFS论文的所有内容，而是选取其中的重点部分进行讲解。</p>
<h3 id="GFS-Architecture"><a href="#GFS-Architecture" class="headerlink" title="GFS Architecture"></a>GFS Architecture</h3><p><img src="/images/gfs/gfs_architecture.png" alt=""><br>在介绍GFS的架构之前，先介绍一下GFS中一个非常重要的概念，即chunk。在GFS中，文件都被划分成固定大小的chunk来进行存储的，比如一个文件是128M，chunk大小被定义为64M（GFS选择的chunk大小就是64M），那么这个文件就可以被分为2个chunk。在GFS中，chunk才是读写的最小处理单位，chunk在创建时会被分配一个全局唯一的64位的chunk handle（可以理解为chunk的身份证）。我们回过头来看架构图，其中有4类角色：  </p>
<ul>
<li><p>GFS chunkserver: 顾名思义，就是存放chunk的服务器。为了可靠性考虑，一个chunk会被同时存储在多个chunk server上。</p>
</li>
<li><p>master：包含了文件系统的所有元数据，包括命名空间、访问控制信息、file到chunk的映射关系和chunk存放的位置。可以说master是整个GFS的大脑，它知道所有的信息，并且系统级的活动都需要它的参与（比如chunk lease管理、垃圾回收和chunk迁移等）。另外，master还会以心跳包的形式与每个chunkserver保持连接。</p>
</li>
<li><p>client：与master和chunkserver进行交互，从而完成数据的读写。其最后的呈现结果是一个专用库，开放了一些API供application调用。</p>
</li>
<li><p>application：上层应用，只需要调用client库的API就可以完成读写。打个比方appl调用了client库的open(“123.txt”),client库就会在内部通过一系列交互，打开与该文件相关的chunk。  </p>
<h4 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h4><p>GFS中单个master的好处在于设计和实现非常简单。但是需要避免的问题就是，在文件读写请求中，要降低master的参与度。打个比方，如果多个client在读写时全程都需要master的参与，那么由于master是单个的，将形成多对一的关系，master所要承担的压力就会急剧上升，从而很容易成为系统的瓶颈。GFS降低master的参与度的方式是：在请求时，应用把（filename，offset）传给client，client转换成（filename，chunk_index），再传给master。master接收到请求后，会把对应chunk的（chunk handle，chunk location）反馈给client。之后的读写都有client和chunkserver交互完成。也就是说对于一次读写，client只与master进行一次交互。</p>
</li>
<li><p>chunk index = offset / chunksize</p>
</li>
<li><p>chunk location就是指这个chunk在哪些chunkserver上</p>
<h4 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h4><p>GFS的chunk大小设置为64MB，其优点和缺点都如下所示：  </p>
</li>
</ul>
<ul>
<li>优点：<ul>
<li>当chunk size较大时，可以减少client和master的交互次数。比如client申请读read(‘1.txt’, 0), read(‘1.txt’, 4096), read(‘1.txt’, 128000),这三次读请求都在1.txt中的第一个chunk，所以实质上client只与master进行了一起交互，即请求1.txt的第一个chunk的位置信息。</li>
<li>chunk越大，那么在该chunk上执行的操作也就越多，那么可以通过持久性TCP连接来减少网络开销。</li>
<li>减少了存储在master中的metadata的大小。比如所有文件大小总和是2560M，如果将chunk size设为32M，则需要80个chunk，也就是80个对应metadata；将chunk size设为64M，则只需要40个chunk，metadata的数量减少了一半。越少的metadata就意味着能将其直接放在master的内存，这样能加快master对client请求的响应速度。</li>
</ul>
</li>
<li>缺点：<ul>
<li>chunk size越大，也就是说很多小文件可能只有一个chunk，那么如果多个client同时访问这个文件，那么存有该chunk的chunkserver将面临高额的负载，即hot spots问题。对于这个问题，google的做法是对于这种chunk进行更多的备份，并且使批处理队列系统错开应用程序的启动时间。另外，google也认为允许client从其他client读取数据可能会是一个长期方法。</li>
</ul>
</li>
</ul>
<h4 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h4><p>GFS master存储着三种metadata：  </p>
<ul>
<li>文件和chunk的namespaces：是文件系统的逻辑元数据，包括层级目录结构以及访问控制等</li>
<li>文件到chunk的映射关系：通过文件名查找到对应的chunks</li>
<li>每个chunk的位置信息：有几个副本，这些副本在哪些chunkserver上  </li>
</ul>
<p>对于前两者，master会记录到操作日志并复制到远端以保证其持久化。操作日志会存储在master和多台远程机器上，只有当operation log在master和远程机器上都写入成功后，master才会响应client的请求。<br>关于chunk的位置信息，master并不做持久化保存，因为chunkserver很容易出现宕机等故障。在每次master重启或者有新的chunkserver加入时，会要求对应的chunkserver汇报其包含的chunk信息。<br>对于metadata，master将其全部存在内存中，这样做的好处在于读取和更新metadata的速度很快。至于master的内存会不会成为系统的瓶颈，因为一个64MB的chunk的metadata不会超过64B，因此64G内存的master可容纳1Gchunk的metadata，如果内存真的成为瓶颈，也可以通过增加内存来解决。</p>
<h3 id="System-Interactions"><a href="#System-Interactions" class="headerlink" title="System Interactions"></a>System Interactions</h3><p>这部分主要讲解GFS的交互过程。</p>
<h4 id="leases-and-Mutation-Order"><a href="#leases-and-Mutation-Order" class="headerlink" title="leases and Mutation Order"></a>leases and Mutation Order</h4><p>lease是分布式系统常用的一种机制，lease相当于一种授权，是由颁布者授予的某一有效期内的承诺，lease的接受者将在lease到期前获得“特权”。<br>之前也提到了master只负责告诉client请求的chunk所在的chunkserver，后续的读写流程master一概不参与。那么考虑这样一个问题，client该怎么与chunksever交互，并且对该chunk的写都同步到其他副本上。针对这个问题，GFS在多个包含同个chunk的chunkserver中选择一个作为primary，授予其lease保证其在一定期限内一直维持primary的身份。而client就与这个primary打交道。<br><img src="/images/gfs/lease.png" alt=""><br>通过这个图，我们具体理解下整个写流程：  </p>
<ol>
<li>client先询问master关于这个chunk的primary位置和其他保存副本的chunkserver位置。</li>
<li>master回复client后，client会缓存primary和其他副本的位置直到lease失效。</li>
<li>client将数据发至所有包含副本的chunkserver（包括primary），这个顺序是随client自己定的。所有的chunkserver在接收到数据后先不更新，而是放入LRU缓存池。</li>
<li>当确认了所有的chunkserver都收到了数据后，client就向primary发送写请求。primary会先进行写操作，然后为这次写请求分配序号，保证从多个客户端的并发写请求有唯一的操作顺序，也保证了副本写入数据的顺序都是一样的。</li>
<li>primary将写请求转发至所有副本，转发顺序由primary指定。</li>
<li>副本写成功后会将响应发给primary</li>
<li>primary再将响应发送给client。</li>
</ol>
<p>当错误发生时，即某些副本未能完成写操作，就会直接发送失败信号给client。client对此的处理是重新发送这个写请求，即重复3~7步骤。另外，当写的内容较大时，client会将其分割成多个写操作。</p>
<h4 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h4><p>回顾之前的写流程的第三步，client需要将数据发送至所有的副本，但是并不是通过由client直接对不同的副本发送消息完成，而是以一种pipeline的方式完成的。  </p>
<ol>
<li>client选择离它最近的chunkserver A发送数据。</li>
<li>chunkserver A收到数据后，转发给离它最近的另一个chunkserver（即primary）。</li>
<li>primary收到数据后，又转发给chunkserver B。</li>
</ol>
<p>也就是通过就近原则，不断地转发数据，直到所有的chunkserver都收到了数据。这种方式有效利用了所有机器的网络带宽。</p>
<h4 id="Atomic-Record-Appends"><a href="#Atomic-Record-Appends" class="headerlink" title="Atomic Record Appends"></a>Atomic Record Appends</h4><p>追加写的流程与写流程差不多，主要有以下区别：</p>
<ul>
<li>client把数据推送到所有副本的最后一个chunk。然后发写请求。</li>
<li>primary先检查最后一个chunk是否能容纳当前写请求。如果可以，就进行写操作；否则，会将最后一个chunk填充到64MB，然后告诉client需要在下一个chunk上重新发起写请求。（显然，这也就意味了GFS不会接受64MB以上的追加写申请，实际上，GFS的追加写内容大小不能超过1/4个chunk size）</li>
</ul>
<h4 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h4><p>读到这里，已经对GFS的交互有了一定了解，接下来我们就来看看GFS的一致性模型。<br><img src="/images/gfs/consistency_model.png" alt=""><br>这里对consistency和defined进行了定义：  </p>
<ul>
<li>consistency：所有client无论从哪个副本读，都能看到相同的内容</li>
<li>defined：但一个文件区域发生修改后，client可以看到修改的所有内容。</li>
</ul>
<p>接着我们对表格中的几种情况进行分析：</p>
<ol>
<li>write（serial success）:串行写（同一时刻只有一个写请求），返回成功时，所有的副本都更新了数据，所以客户端都能看到这次操作写入的数据，所以是defined。</li>
<li>write（concurrent success）：并发写，返回成功时，由于写的顺序由primary来决定，并且多个写请求可能有区域重叠，最终完成的数据可能是多个写操作叠加起来的结果，所以是consistency和undefined。</li>
<li>write（failure）：写操作失败时，有的副本写入了数据，有的没有，所以是inconsistent。</li>
<li>Record Append（serial success and concurrent success）：由于内容都是追加至末尾，那么肯定是defined。但是假如其中经历了一次failure，然后重试之后才成功，那么状态就会是interspersed with inconsistent。</li>
<li>Record Append（failure）：部分追加成功，部分失败，所以是inconsistent。</li>
</ol>
<h3 id="Master-Operation"><a href="#Master-Operation" class="headerlink" title="Master Operation"></a>Master Operation</h3><p>master的功能包括namespace operations，make placement decision，create new chunks and hence replicas等等。</p>
<h4 id="Namespace-Management-and-Locking"><a href="#Namespace-Management-and-Locking" class="headerlink" title="Namespace Management and Locking"></a>Namespace Management and Locking</h4><p>master的每个操作都需要获得一些列的锁，其实质是基于文件路径的读写锁。比如，client要创建/home/usr/new_file，那么就需要获取/home，/home/usr的读锁和/home/usr/new_file的写锁。</p>
<h4 id="Replica-Placement"><a href="#Replica-Placement" class="headerlink" title="Replica Placement"></a>Replica Placement</h4><p>把每个chunk的副本分散在不同的机架上，从而利用多个机架的带宽，并且提高chunk的可靠性（避免机架级故障）。</p>
<h4 id="Creation-Re-replicaton-Rebalancing"><a href="#Creation-Re-replicaton-Rebalancing" class="headerlink" title="Creation, Re-replicaton, Rebalancing"></a>Creation, Re-replicaton, Rebalancing</h4><p>在创建chunk时，会根据多种考量来选择合适的chunkserver，比如选择磁盘空间利用率低于平均值的chunkserver等。<br>当一个chunk的副本数少于预期的时候，需要增加副本的数量。<br>还有通过检查副本分布情况，然后调整更好的磁盘使用情况和做好负载均衡。</p>
<h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><p>GFS删除文件后，并不会马上进行物理删除，而是在定期的清理行为中才会对可删除的文件进行清除。具体的清除规则和过程这里不多讲。</p>
<h3 id="High-Availability"><a href="#High-Availability" class="headerlink" title="High Availability"></a>High Availability</h3><p>GFS通过fast recovery和replication来实现高可用性。  </p>
<ul>
<li>fast recovery：指的是master和chunkserver都能在几秒内完成启动。</li>
<li>replication：也就是多副本，GFS中对chunk、master的operation logs等都会进行多副本处理。</li>
</ul>
<p>最后，再说明下，chunkserver会通过checksum来验证数据是否损坏。每个chunk被分为64KB的块，每个块有一个32b的checksum，checksum会在chunkserver的内存和日志中存储。对于读请求，chunkserver如果检测到一个block的checksum不对，就会报错给client和master。client就会从另一个副本读取消息，master也会重新复制一个副本（复制完成后，删除这个出错的副本）。</p>
<h2 id="GFS-Demo"><a href="#GFS-Demo" class="headerlink" title="GFS Demo"></a>GFS Demo</h2><p>根据GFS的论文思想，我用java语言实现了一个简单GFS Demo，整个demo放弃了网络通信和一些细节实现，主要就是直观描述了create，write，read调用的过程，该demo已经放在了我的github上，链接地址是<a href="https://github.com/twdlll/gfsdemo" target="_blank" rel="noopener">gfs demo</a>。下面的代码展示都略过了不重要的代码。</p>
<h3 id="GFS-Demo-Element"><a href="#GFS-Demo-Element" class="headerlink" title="GFS Demo Element"></a>GFS Demo Element</h3><p>这里我在element包下创建了三个类，ChunkRequest，ChunkMetaData和Chunk。</p>
<h4 id="ChunkRequest"><a href="#ChunkRequest" class="headerlink" title="ChunkRequest"></a>ChunkRequest</h4><p>ChunkRequest主要包括文件名和对应的chunk index。当client收到外部的读写请求时，client计算出原始offset对应的chunk index，并和filename组装成ChunkRequest，通过ChunkRequest向master发起请求，获取对应chunk的metadata。</p>
<pre><code>public class ChunkRequest {
    private String filename;
    private int chunkIndex;
    public String getFilename() {
        return filename;
    }
    public int getChunkIndex() {
        return chunkIndex;
    }
    public ChunkRequest(String filename, int chunkIndex) {
        this.filename = filename;
        this.chunkIndex = chunkIndex;
    }
    ...
}</code></pre><h4 id="ChunkMetadata"><a href="#ChunkMetadata" class="headerlink" title="ChunkMetadata"></a>ChunkMetadata</h4><p>这里设定的metadata的大小是1024KB, 这里的metadata没有论文里那么细致，仅仅是简单地记录了chunk handle和存放的chunkserver。</p>
<pre><code>public class ChunkMetadata {
    public static final int CHUNK_SIZE = 1 &lt;&lt; 10;
    private int chunkHandle;
    private ChunkServer[] chunkServers;
    public ChunkMetadata(int chunkHandle, ChunkServer[] chunkServers) {
        this.chunkHandle = chunkHandle;
        this.chunkServers = chunkServers;
    }
    ...
}</code></pre><h4 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h4><p>chunk本质上也是一个文件，这这里chunk是一个最大容量为1024KB的文件。同时chunk也是read和write动作的真正执行者。</p>
<pre><code>public class Chunk {
    private int chunkHandle;
    private final String filename;
    private FileChannel fileChannel;
    private Logger logger;
    public int getChunkHandle() {
        return chunkHandle;
    }
    public void setChunkHandle(int chunkHandle) {
        this.chunkHandle = chunkHandle;
    }
    public String getFilename() {
        return filename;
    }
    public Chunk(int chunkHandle, String prefix) {
        this.chunkHandle = chunkHandle;
        filename = String.format(&quot;%s/%d.chunk&quot;, prefix, this.chunkHandle);
        logger = LoggerFactory.getLogger(filename);
        try {
            fileChannel = new RandomAccessFile(filename, &quot;rw&quot;).getChannel();
        } catch (IOException e) {
            logger.error(&quot;open chunk error&quot;);
        }
    }
    public ByteBuffer read(int offset, int len) {}
    public boolean write(int offset, ByteBuffer byteBuffer) {}

}</code></pre><h3 id="GFS-Demo-Role"><a href="#GFS-Demo-Role" class="headerlink" title="GFS Demo Role"></a>GFS Demo Role</h3><p>role包下是整个demo的重点，包括了Master，Client和Chunkserver。这里副本的个数设为3。另外，这里的create和write都需要primary的参与。</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>client受外部调用，通过与master和chunkserver的交互完成读写任务。</p>
<pre><code>public class Client {
    // 对应的master
    private Master master;
    // metadata缓存
    private Map&lt;ChunkRequest, ChunkMetadata&gt; chunkMetadataCache = new HashMap&lt;&gt;();
    private Logger logger = LoggerFactory.getLogger(Client.class);
    public Client(Master master) {
        this.master = master;
    }
    // 根据原始文件的offset，计算对应的chunk index
    private int computeChunkIndex(int offset) {
        return offset / ChunkMetadata.CHUNK_SIZE ;
    }

    // 根据文件名，原始offset和请求类型获取对应chunk的metadata
    private ChunkMetadata getChunkMetadata(String filename, int offset, int request) {
        int chunkIndex = computeChunkIndex(offset);
        // 封装成ChunkRequest
        ChunkRequest chunkRequest = new ChunkRequest(filename, chunkIndex);    
        // 现在缓存中查找是否有对应的metadata
        ChunkMetadata metadata = chunkMetadataCache.getOrDefault(chunkRequest, null);
        if (null == metadata) {
            // 缓存中没有，就去向master请求metadata
            metadata = master.getChunkMetadata(chunkRequest, request);
            if (null == metadata) {
                logger.info(&quot;get chunk&apos;s metadata error&quot;);
                return null;
            }
            // 将得到的metadata更新至缓存
            chunkMetadataCache.put(chunkRequest, metadata);
        }
        return metadata;
    }

    // 创建文件API
    public boolean create(String filename) {
        // 获取metadata，创建文件被认为是创建该文件的第一个chunk
        ChunkMetadata metadata = getChunkMetadata(filename, 0, Master.REQUEST_CREATE);
        if (null == metadata) {
            // 失败主要是文件已被创建
            logger.info(&quot;create file {} error&quot;, filename);
            return false;
        }
        // 第一个server是primary
        ChunkServer[] servers = metadata.getChunkServers();
        // 向primary发送create请求
        boolean success = servers[0].create(metadata.getChunkHandle());
        if (success) {
            logger.info(&quot;create file {} success&quot;, filename);
        } else {
            logger.info(&quot;create file {} error&quot;, filename);
        }
        return success;
    }

    // 读API
    public ByteBuffer read(String filename, int offset, int len) {
        ChunkMetadata metadata = getChunkMetadata(filename, offset, Master.REQUEST_READ);
        // 读不需要primary的参与，所以随机选一个副本进行读操作
        int selectIndex = new Random().nextInt(Master.REPLICA_NUM);
        return metadata.getChunkServers()[selectIndex].read(metadata.getChunkHandle(), offset % ChunkMetadata.CHUNK_SIZE, len);
    }


    // 写API
    public boolean write(String filename, int offset, ByteBuffer buffer) {
        ChunkMetadata metadata = getChunkMetadata(filename, offset, Master.REQUEST_WRITE);
        // 将原始offset转化为chunk内部的offset
        offset = offset % ChunkMetadata.CHUNK_SIZE;
        ChunkServer[] servers = metadata.getChunkServers();
        // 先将数据推送到3个副本所在的chunkserver
        logger.info(&quot;begin push data&quot;);
        for (ChunkServer server : servers) {
            if (!server.push(metadata.getChunkHandle(), offset, buffer)) {
                logger.error(&quot;push data error&quot;);
                return false;
            }
        }
        logger.info(&quot;push data success&quot;);
        // 向primary发起写请求
        boolean finish = false;
        if ((finish = servers[0].write(metadata.getChunkHandle(), offset))) {
            logger.info(&quot;write data success&quot;);
        } else {
            logger.error(&quot;write data error&quot;);
        }
        return finish;
    }
}</code></pre><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>master主要负责响应client的metadata请求，已经primary lease的授权，这里的lease无有效期限制。</p>
<pre><code>public class Master {
    // 实时地记录了每个chunkserver的负载情况
    private static class ChunkServerInfo implements Comparable&lt;ChunkServerInfo&gt;{
        ChunkServer server;
        int chunkNum = 0;
        ChunkServerInfo(ChunkServer server, int chunkNum) {
            this.server = server;
            this.chunkNum = chunkNum;
        }
        @Override
        public int compareTo(ChunkServerInfo o) {
            return Integer.compare(chunkNum, o.chunkNum);
        }
    }

    // 不同的请求定义
    public static final int REQUEST_CREATE = 1;
    public static final int REQUEST_READ = 2;
    public static final int REQUEST_WRITE = 3;

    // 存储chunk metadata信息，映射关系是 （chunk handle) -&gt; (chunk metadata)
    private Map&lt;Integer, ChunkMetadata&gt; chunkMetadataMap = new HashMap&lt;&gt;();

    // 副本数量
    public static final int REPLICA_NUM = 3;

    // 包含所有的chunkserver
    private List&lt;ChunkServer&gt; chunkServers = new ArrayList&lt;&gt;();

    // 用于创建新块的时候选择
    private List&lt;ChunkServerInfo&gt; chunkServerInfos = new ArrayList&lt;&gt;();

    public Master() { }

    // 添加新的chunkserver
    public void addChunkServers(ChunkServer server) {
        chunkServers.add(server);
    }

    // 添加新的chunkserver信息
    public void addChunkServerInfo(ChunkServer server, int chunkNum) {
        ChunkServerInfo info = new ChunkServerInfo(server, chunkNum);
        chunkServerInfos.add(info);
    }

    // chunkhandle由chunkRequest的filename和chunk index计算得到
    private int computeChunkHandle(ChunkRequest chunkRequest) {
        return chunkRequest.getFilename().hashCode() * 100 + chunkRequest.getChunkIndex();
    }

    // 响应client的请求，返回对应chunk的metadata
    public ChunkMetadata getChunkMetadata(ChunkRequest chunkRequest, int request) {
        int chunkHandle = computeChunkHandle(chunkRequest);
        ChunkMetadata metadata = chunkMetadataMap.getOrDefault(chunkHandle, null);
        if (null == metadata) {
            if (REQUEST_CREATE == request) {
                // 对于create请求，显然对应chunk是不存在的，所以创建一个新的metadata
                metadata = createChunkMetadata(chunkRequest);
                // 将第一个chunkserver设置成primary
                metadata.getChunkServers()[0].becomePrimary(metadata);
            } else if (REQUEST_READ == request) {
                // 对于读请求，如果对应的chunk不存在，那显然就不能读，返回null
                return null;
            } else {
                // 对于写请求，chunk不存在有两种情况
                // 1. 该chunk对应的文件未存在，此时拒绝写请求
                // 2. 该chunk对应的文件存在，但是文件中的当前chunk不存在，此时应该创建chunk
                // 对于第2种情况，比如abc.txt已经创建了（也就是说该文件的chunk0已经存在了），但是要写chunk1的内容时
                // 发现chunk1未创建，所以要先创建chunk1，然后回应client的write请求
                ChunkRequest fileRequest = new ChunkRequest(chunkRequest.getFilename(), 0);
                int fileChunkHandle = computeChunkHandle(fileRequest);
                if (chunkMetadataMap.containsKey(fileChunkHandle)) {
                    // chunk对应的文件已经创建,创建新chunk的metadata
                    metadata = createChunkMetadata(chunkRequest);
                    // 使第一个chunkserver成为primary
                    metadata.getChunkServers()[0].becomePrimary(metadata);
                    // 让primary完成chunk的创建工作
                    metadata.getChunkServers()[0].create(metadata.getChunkHandle());
                }
            }
        } else {
            if (REQUEST_CREATE == request) {
                // chunk的metadata已经存在，但是还要求创建，则返回null
                return null;
            } else {
                // 无论是读还是写，都授予第一个chunkserver为primary
                // 实际上读的话不需要primary，这里只是为了实现方便
                metadata.getChunkServers()[0].becomePrimary(metadata);
            }
        }
        return metadata;
    }

    // 创建新chunk的metadata，这里的metadata不直接加入到chunkMetadataMap里
    private ChunkMetadata createChunkMetadata(ChunkRequest chunkRequest) {
        int chunkHandle = computeChunkHandle(chunkRequest);
        // select chunkservers
        ChunkServer[] servers = new ChunkServer[REPLICA_NUM];
        Collections.sort(chunkServerInfos);
        for (int i = 0; i &lt; REPLICA_NUM; i++) {
            servers[i] = chunkServerInfos.get(i).server;
        }
        ChunkMetadata metadata = new ChunkMetadata(chunkHandle, servers);
        return metadata;
    }

    // 当chunserver完成新chunk的创建后，将调用这个方法将新的metadata添加至master中
    public void addChunkMetatdat(ChunkMetadata metadata) {
        chunkMetadataMap.put(metadata.getChunkHandle(), metadata);
        // 更新各个chunserver的信息，用于负载均衡
        Set&lt;ChunkServer&gt; servers = new HashSet&lt;&gt;(Arrays.asList(metadata.getChunkServers()));
        for (ChunkServerInfo info : chunkServerInfos) {
            if (servers.contains(info.server)) {
                info.chunkNum++;
            }
        }
    }

    // 当chunserver启动时，会检查自身拥有的chunk，并汇报给master
    public void reportChunkMetadata(int chunkHandle, ChunkServer server) {
        ChunkMetadata metadata = chunkMetadataMap.getOrDefault(chunkHandle, null);
        if (null == metadata) {
            // 更新chunkMetadataMap
            metadata = new ChunkMetadata(chunkHandle, new ChunkServer[REPLICA_NUM]);
            chunkMetadataMap.put(chunkHandle, metadata);
        }
        ChunkServer[] servers = metadata.getChunkServers();
        for (int i = 0; i &lt; REPLICA_NUM; i++) {
            if (null == servers[i]) {
                servers[i] = server;
                break;
            }
        }
    }

    public void printChunkServerInfos() {
        System.out.println(&quot;chunserver : chunkname&quot;);
        for (ChunkServerInfo info : chunkServerInfos) {
            System.out.println(info.server.getChunkServerName() + &quot; : &quot; + info.chunkNum);
        }
    }
}</code></pre><h4 id="Chunkserver"><a href="#Chunkserver" class="headerlink" title="Chunkserver"></a>Chunkserver</h4><p>chunkserver承担了create、read和write的大部分工作。</p>
<pre><code>public class ChunkServer {
    // 由于所有chunkserver都是模拟出来的，所以通过不同的根目录模拟不同chunkserver的磁盘空间
    private String rootFolder;

    public String getChunkServerName() {
        return chunkServerName;
    }
    private String chunkServerName;

    // 该chunkserver所拥有的chunks
    private Map&lt;Integer, Chunk&gt; chunks;

    // 以该chunkserver为primary的所有chunk metadatas
    private Map&lt;Integer, ChunkMetadata&gt; primaries;

    private Master master;

    // 缓冲数据，用于容纳client push的data
    private static class BufferedData {
        int chunkHandle;
        int offset;
        ByteBuffer buffer;
        BufferedData(int chunkHandle, int offset, ByteBuffer buffer) {
            this.chunkHandle = chunkHandle;
            this.offset = offset;
            this.buffer = buffer;
        }
    }
    // 缓冲池，承载缓冲数据
    private List&lt;BufferedData&gt; bufferedDatas = new ArrayList&lt;&gt;();

    private Logger logger;

    public ChunkServer(String rootFolder, Master master) {
        this.master = master;
        this.master.addChunkServers(this);
        this.rootFolder = rootFolder;
        chunks = new HashMap&lt;&gt;();
        primaries = new HashMap&lt;&gt;();
        chunkServerName = String.format(&quot;chunkserver-%s&quot;, rootFolder);
        logger = LoggerFactory.getLogger(chunkServerName);
        File rootDir = new File(rootFolder);
        if (rootDir.exists()) {
            // 根目录已经创建，检查内部的chunks
            checkChunks();
        } else {
            // 创建根目录
            if (!rootDir.mkdir()) {
                logger.info(&quot;create root folder error&quot;);
            }
        }
        // 将该chunkserver的信息添加至master
        master.addChunkServerInfo(this, chunks.size());
    }


    private void checkChunks() {
        File rootDir = new File(rootFolder);
        File[] files = rootDir.listFiles();
        if (null == files) {
            return ;
        }
        for (File file : files) {
            if (file.isFile()) {
                // chunk的存储形式为123.chunk，123就是该chunk的chunk handle
                // 所以分割文件名，创建chunk对象，并加入到chunks中
                String filename = file.getName();
                int chunkHandle = Integer.parseInt(filename.substring(0, filename.lastIndexOf(&apos;.&apos;)));
                chunks.put(chunkHandle, new Chunk(chunkHandle, rootFolder));
                // 报告给master
                master.reportChunkMetadata(chunkHandle, this);
            }
        }
    }

    // 响应create请求
    public boolean create(int chunkHandle) {
        if (!chunks.containsKey(chunkHandle)) {
            // 创建chunk
            Chunk chunk = new Chunk(chunkHandle, rootFolder);
            chunks.put(chunkHandle, chunk);
        }
        if (primaries.containsKey(chunkHandle)) {
            // 该chunkserver是这个chunk的primary
            ChunkMetadata metadata = primaries.get(chunkHandle);
            for (ChunkServer server : metadata.getChunkServers()) {
                // 让其他的chunkserver发起create操作
                if (this != server &amp;&amp; !server.create(chunkHandle)) {
                    return false;
                }
            }
            // 新chunk在3个chunkserver上创建成功，汇报给master
            master.addChunkMetatdat(metadata);
            logger.info(&quot;primary create new chunk({}.chunk)&quot;, chunkHandle);
            return true;
        }
        logger.info(&quot;secondary create new chunk({}.chunk)&quot;, chunkHandle);
        return true;
    }

    public int getChunkNum() {
        return chunks.size();
    }

    // 读操作
    public ByteBuffer read(int chunkHandle, int offset, int len) {
        if (!chunks.containsKey(chunkHandle)) {
            logger.error(&quot;the file does not exist&quot;);
            return null;
        }
        Chunk chunk = chunks.get(chunkHandle);
        return chunk.read(offset, len);
    }

    // 供client推送缓存数据
    public boolean push(int chunkHandle, int offset, ByteBuffer buffer) {
        BufferedData bufferedData = new BufferedData(chunkHandle, offset, buffer);
        if (!bufferedDatas.contains(bufferedData)) {
            bufferedDatas.add(bufferedData);
            logger.info(&quot;receive pushed data success&quot;);
        }
        return true;
    }

    // 从缓存池中找到对应的缓存数据
    private BufferedData getBufferedData(int chunkHandle, int offset) {
        BufferedData retData = null;
        for (BufferedData data : bufferedDatas) {
            // search data in buffer
            if (chunkHandle == data.chunkHandle &amp;&amp; offset == data.offset) {
                retData = data;
                break;
            }
        }
        if (null != retData) {
            // remove data in buffer
            bufferedDatas.remove(retData);
        }
        return retData;
    }

    // 执行写操作
    public boolean write(int chunkHandle, int offset) {
        BufferedData bufferedData = getBufferedData(chunkHandle, offset);
        if (null == bufferedData) {
            logger.error(&quot;can&apos;t find buffered data ({}:{})&quot;, chunkHandle, offset);
            return false;
        }
        Chunk chunk = chunks.get(chunkHandle);
        bufferedData.buffer.rewind();
        if (!chunk.write(offset, bufferedData.buffer)) {
            logger.error(&quot;{}&apos;s {} write data error&quot;,
                    chunkHandle,
                    primaries.containsKey(chunkHandle) ? &quot;primary&quot; : &quot;secondary&quot;);
            return false;
        }
        if (primaries.containsKey(chunkHandle)) {
            // primary已经写入，让其他chunkserver执行写操作
            ChunkMetadata metadata = primaries.get(chunkHandle);
            ChunkServer[] servers = metadata.getChunkServers();
            for (int i = 1; i &lt; Master.REPLICA_NUM; i++) {
                if (!servers[i].write(chunkHandle, offset)) {
                    // 如果有一个chunkserver写失败，则本次写请求失败
                    logger.error(&quot;secondary write error&quot;);
                    return false;
                }
            }
            logger.info(&quot;primary write success&quot;);
            return true;
        }
        logger.info(&quot;secondary write success&quot;);
        return true;
    }

    // 成为对应chunk的primary
    public void becomePrimary(ChunkMetadata metadata) {
        primaries.put(metadata.getChunkHandle(), metadata);
    }
}</code></pre><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>测试上述create，write，read流程。</p>
<pre><code>public class Demo {
    public static void main(String[] args) {
        // 1个master，1个client，10个chunkserver
        Master master = new Master();
        Client client = new Client(master);
        List&lt;ChunkServer&gt; servers = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            servers.add(new ChunkServer(String.valueOf(i), master));
        }

        // 创建文件测试
        client.create(&quot;first.txt&quot;);
        client.create(&quot;second.txt&quot;);
        client.create(&quot;third.txt&quot;);
        client.create(&quot;fourth.txt&quot;);

        // master.printChunkServerInfos();

        // 写测试
        String writeData = &quot;abcdefg,hijklmn&quot;;
        client.write(&quot;fourth.txt&quot;, 1800, ByteBuffer.wrap(writeData.getBytes(StandardCharsets.UTF_8)));

        // 读测试
        ByteBuffer buffer = client.read(&quot;fourth.txt&quot;, 1800, 5);
    }
}</code></pre><p>结果应该如下所示：<br><img src="/images/gfs/gfsdemo_result.png" alt=""></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/gfs/" rel="tag"><i class="fa fa-tag"></i>gfs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/slf4j/" rel="next" title="SLF4J源码分析">
                <i class="fa fa-chevron-left"></i> SLF4J源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/05/idea/" rel="prev" title="idea相关">
                idea相关 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/me.jpg"
                alt="Twd" />
            
              <p class="site-author-name" itemprop="name">Twd</p>
              <p class="site-description motion-element" itemprop="description">There is no royal road to learning.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Google-File-System"><span class="nav-number">1.</span> <span class="nav-text">The Google File System</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GFS论文理解"><span class="nav-number">1.1.</span> <span class="nav-text">GFS论文理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GFS-Architecture"><span class="nav-number">1.1.1.</span> <span class="nav-text">GFS Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Single-Master"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Single Master</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chunk-Size"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Chunk Size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Metadata"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Metadata</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Interactions"><span class="nav-number">1.1.2.</span> <span class="nav-text">System Interactions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#leases-and-Mutation-Order"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">leases and Mutation Order</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Data-Flow"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Data Flow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Atomic-Record-Appends"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Atomic Record Appends</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consistency-Model"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">Consistency Model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Master-Operation"><span class="nav-number">1.1.3.</span> <span class="nav-text">Master Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Namespace-Management-and-Locking"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Namespace Management and Locking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replica-Placement"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Replica Placement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Creation-Re-replicaton-Rebalancing"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Creation, Re-replicaton, Rebalancing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Garbage-Collection"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Garbage Collection</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#High-Availability"><span class="nav-number">1.1.4.</span> <span class="nav-text">High Availability</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GFS-Demo"><span class="nav-number">1.2.</span> <span class="nav-text">GFS Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GFS-Demo-Element"><span class="nav-number">1.2.1.</span> <span class="nav-text">GFS Demo Element</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ChunkRequest"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">ChunkRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChunkMetadata"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">ChunkMetadata</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chunk"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">Chunk</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GFS-Demo-Role"><span class="nav-number">1.2.2.</span> <span class="nav-text">GFS Demo Role</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Client"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Master"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Master</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chunkserver"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Chunkserver</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Demo"><span class="nav-number">1.2.3.</span> <span class="nav-text">Demo</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Twd</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
